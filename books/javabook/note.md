## 2. 基本的な書き方を身につける

- 修飾子
	- `transient`
		- フィールドをシリアライズ対象から除外
		- オブジェクトのファイル保存、ネットワーク送受信時などに不要になる一時データをシリアライズしなくて済む
	- `volatile`
		- マルチスレッドからアクセスされるフィールドに対して、スレッドごとに値がキャッシュされないようにする
		- スレッドセーフのため
	- `synchronized`
		- メソッドまたはブロックの同期
		- 同時に1つのスレッドからしかアクセスされないことが保証される
	- `native`
		- メソッドがネイティブコード（C/C++で書かれたDLL, 共有ライブラリなど）を呼び出す
	- `strictfp`
		- クラス、インタフェース、メソッドで浮動小数点数をIEEE 754規格で厳密に処理する
		- 厳密な浮動小数点演算によって、プラットフォーム間の移植性向上
- 変数名の後ろに `_` をつけるのはもはや不要
	- IDEで書くのが当たり前なので、フィールドとローカル変数の名前が一緒でも区別がつく
	- フレームワークによっては末尾の `_` によって変数のバインドに失敗するものもある
- 変数は名詞、メソッドは動詞で命名
	- booleanの変数名に `isXxx` とつけるのは違う
	- 変数名は `xxx` で、問い合わせるメソッドが `isXxx` と命名されるべき

## 3. 型を極める

- プリミティブ型
	- 桁数の多い数字はアンダースコアで区切りを表現できる：`long amount = 123_456_789L;`
	- Widening（ワイドニング；型のデータサイズが大きくなるような自動変換）は整合性が保たれる
		- e.g., short -> int
	- 逆に Narrowing（ナローイング）はコンパイルエラー (e.g., int -> short)
		- キャストすればコンパイルは通るけど、値はおかしくなる：`short shortNum = (short) intNum`
- 参照型
	- Wrapper Class：プリミティブ型を内包し、そのプリミティブ型の値を操作する機能を備えたもの
		- int <-> Integer, double <-> Double, ...
		- `Integer.MAX_VALUE`, `Float.MIN_VALUE`, ...
	- プリミティブ型からラッパークラスへの変換は、`valueOf`を使うと-127~128の範囲では事前に生成されたオブジェクトが利用できるので、メモリに優しい
	- プリミティブ型のintの初期値は0だが、ラッパークラスではNULL
		- ゼロとNULLを区別したいときはラッパークラスを使う
			- HTTP通信で取得した値やファイルから読み込んだ値のストアなど
	- Autoboxing: Primitive -> Wrapper Classへの変換 `Integer numInt = 10`
	- Unboxing: Wrapper Class -> Primitiveへの変換 `10 + Integer.valueOf(10)`
		- 依存しすぎると、ラッパークラスを誤って `==` で比較してしまってFalseになる、といったミスが発生する
			- -128 ~ 127の値をautoboxingしたオブジェクトだけは、事前に生成されたオブジェクトを使うので例外的に一致する
		- というわけで
			1. 原則としてautoboxing, unboxingは使用せず、明示的に変換
			2. ファイル、DB、HTTPリクエストなどの結果得られる値を保持する場合はラッパークラス
			3. 数値計算はプリミティブ型
			4. 記述量の削減（型変換を明記しないこと）が効果的な場合に限り、autoboxing, unboxingを利用
- クラス
	- 慣例として、他者が提供するライブラリやフレームワークなどとパッケージ名が重複してしまわないよう、自分が所有しているドメイン名を逆にしたものからパッケージ名を始める
	- フィールド、メソッドの修飾子は指定しないとパッケージプライベート（同一パッケージ内のクラスからのみ参照可能；`protected`はそれに加えて子クラスからも参照可能）
	- インタフェース
		- 絶対publicになるが、著者は省略せずに `public interface` とかく
		- メソッド定義のみで、処理は記述できない
			- が、Java8からは処理内容を定義する `default` メソッドが追加された
		- 匿名クラス
			- `public interface TaskHandler { ... }` -> `TaskHandler taskHandler = new TaskHandler() { ... };`
			- クラスを特定の一箇所で使うだけなら、 `implement` した名前のあるクラスを定義するよりもかんたん
	- nested class の使い方はEffective Java参照
- オブジェクトの等価性
	- `public boolean equals(Object obj)`
		- フィールドの値に基づく比較（値を1つずつ比較するので時間がかかる）
	- `public int hashCode()`
		- 同じオブジェクトなら同じハッシュ値を返す
		- ハッシュ値が異なれば異なるオブジェクト
		- 異なるオブジェクトでもハッシュ値が異なることはある
		- （intの値の比較だけなので高速）
	- `HashMap` や `HashSet` では、
		1. 最初にハッシュ値でオブジェクトを比較
		2. ハッシュ値が一致した場合に限り、`equals()`で厳密に値の一致判定
	- `equals()` と `hashCode()` の両方で等価だと判断されないと、オブジェクトはイコールにならない
		- 両メソッドはEclipseだとフィールドに基づいて自動生成される
		- `Objects.hash(v1, v2, ...)` を使えばハッシュ値生成簡単
- `enum`
	- `public static final` による定数は型安全ではない
		- `String COLOR_RED`, `String COLOR_GREEN`, `String COLOR_BLUE` のいずれかを取りたいメソッドを書くとき、引数の型はただの `String` になるので、 `"aaa"` のような意図しない入力も受け付けてしまう
		- 定数をコンパイルした結果はただの値； `String s = COLOR_RED` でも、コンパイル結果は `String s = "red"`
	- なので、`enum`型でいくつかの定数の集まりを表現する
		```
		public enum Color {
			RED, GREEN, BLUE
		};
		```
		- すると、`setColor(Color c)` のような、想定した値以外は受け付けない型安全な定数利用が可能
	- フィールドやメソッドの定義も可能
		```
		public enum HttpStatus {
			OK(200), NOT_FOUND(404), INTERNAL_SERVER_ERROR(500);

			private final int value;

			private HttpStatus(int value) { // enum のコンストラクタは private
				this.value = value;
			}
			public int getValue() {
				return value;
			}
		}
		```
- ジェネリクスで様々な型を受け付ける汎用的なクラス・メソッド定義

## 4. 配列とコレクションを極める

### 配列

- プリミティブ型は0初期化、ラッパークラス（オブジェクト）ではNULL初期化
- `int[] ary` でも `int ary[]` でもいいけど、『○○型の配列』であることを明示するために `int[]` をおすすめ
- 宣言時に内容が決まっていなければ `new int[10]` で初期化するが、書写はこの場合コレクションを利用することのほうが多い
- 宣言時の初期化は `int[] ary = {1, 2, 3}` or `int[] ary = new int[] {1, 2, 3}`；宣言済み配列への代入（引数含む）は後者のみ可能
- 要素数の変更は `Arrays.copyOf` で新規作成＆コピーするが、そもそも要素数可変なら最初からコレクションを利用したい
- `Arrays.sort` でソート
	- プリミティブ型：値の昇順
	- オブジェクト：ComparableインタフェースのcompareToメソッドで並び替え
		- Comparatorを引数に渡してソートするか、対象のクラスをComparableインタフェースのimplementsとして定義してcompareToメソッドを実装するか、2種類選べる
		- しかし後者は「そのクラスがもつデフォルトの並び順によるソート」を定義するので、最も自然な並びであるべきで、しかしそれは自明ではない
		- 多くのクラスは業務上の要件によって“自然な並び”の定義が異なるので、Comparatorを使ったソートを使うことがほとんど
- サーチ
	- 同じデータに対して何度も探索するなら、ソート→バイナリサーチ
	- 一度だけなら線形探索など、バイナリサーチ以外の方法で
- 可変長引数
	- `void log(String message, String... args)`

どのコレクションインタフェース `List`（インデックスを指定して値を取得、設定をしたい）, `Set`（要素に重複がなく、検索・ソートを高速にしたい）, `Map` (key-value pair) を決めたら、どの実装を選ぶかを検討する：

### List

- Listを for-each と iterator のどちらで探索するか？
	- 要素に対する操作（削除、更新）も行いたい時は iterator
- `ArrayList`
	- **forなどをつかった全体的な繰り返し処理向き**
	- 内部に配列を保持していて、そのサイズは何も指定しないと10
	- このサイズを超えるとき、「よりサイズの大きい配列を新たに生成して、元の配列から全要素をコピーする」処理が発生して非効率
	- 要素数の目安が事前についているのなら、コンストラクタでそれを設定したほうが無駄な配列生成＆コピー処理が削減できる
	- インデックスを指定した要素の代入・取得は高速
	- 配列なので、リストの途中の要素の代入・削除はおそい
- `LinkedList`
	- **配列をiterateしつつ、途中で要素の追加/削除を行うとき**
	- 初期サイズの概念はない
	- ArrayListとは逆で、インデックスを指定した要素の代入・取得は時間がかかる
	- 最初から順番に（＝iterator通りに）舐める処理でアドバンテージ
- `CopyOnWriteArray`
	- **複数のスレッドから同時にアクセスしても正しく処理される**ArrayList の拡張
	- ループ実行時に元のリストをコピーして、そのリストに対してループを実行する
	- なのでオリジナルの値は一定で、スレッドからの同時アクセスによるConcurrentModificationExceptionが防げる
	- 性能はほぼArrayListと同等だが、ループや要素の追加・変更・削除時には内部的な配列のコピーが発生するので、その分遅くなる

### Map

- `HashMap`
	- キーの `hasCode` メソッドでハッシュ値計算→ハッシュテーブルのサイズで割った余りをインデックスにする
		- 当然衝突することもあるので、内部的にはLinkedListのような構造の場所にキーと値のペアを格納していて、衝突時は末尾に追加
	- 値を取り出すとき、同一インデックスに複数のEntryがあれば先頭から順に `equals` で比較しながら一致するkey-valueペアをlookup
	- ハッシュテーブルの初期サイズは16で、要素数がその75％に達するとサイズを自動で拡張する
		- サイズ <<< 要素数 だとハッシュ値の競合が増えてloopupに時間がかかるようになるため　
	- 要素の追加順序は保持されないので、イテレータは追加時とは異なる順番
	- **次の3つが適さない、その他の場合に使う**
- `ConcurrentHashMap`
	- **複数スレッドから同時にアクセスする場合**
	- ハッシュテーブルの拡張と要素の追加が同時に起こると無限ループになりうるので、atomicに複数スレッドからの処理をさばく
	- `synchronized` を使うのも手
- `LinkedHashMap`
	- **要素の追加順序を保持したいとき**
	- HashMapのサブクラスで、要素が前後のリンクをもつ
	- リンクの付け替えオーバーヘッドがあるが、HashMapとほぼ変わらない性能
	- HashMapはハッシュ値計算→重複時にリストの列挙が発生するので、全要素の列挙ならこちらのほうが高速
- `TreeMap`
	- **キーの大小を意識するとき**
	- Binary Search Treeを使うので、要素の追加・削除・検索はO(logn)
		- 頻繁に追加・削除・検索をするとHashMapなど他のMapと比較して処理時間の差が顕著に出る

### Set

- 内部的にはMapを持っていて、キーだけを使っているのがSet
	- 値は null 以外ならなんでもいいけど、通常は true
- なので実装、使い分けはMapと同じ
	- `HashSet`
	- `LinkedHashSet`
	- `TreeSet`
- ConcurrentHashSet は存在しない
	- `Collections.newSetFromMap()` で ConcurrentHashMap からセットが作れるので

### その他

- `Queue`
	- バッファ（データの一時保存場所；通信処理などで使う）として使われる
	- マルチスレッドだと異なるスレッドが保存・取り出しを行うので、スレッドセーフな Blocking Queue を使う必要アリ
- `Dequeue`
	- 双方向の値の出し入れが可能なQueue
	- 筆者は使うことはほぼ無い

## 5. ストリーム処理を使いこなす

- Java8から：ラムダ式とStream API
- Stream API
	- **ストリームの作成** (collection, array -> stream)
	- **中間操作**（filterなど；stream -> stream）
	- **終端操作**（forEachによる出力など；stream -> collection, array, element-wise process, aggregate）
- ラムダ式
	- Comparatorが簡単にかける
		- Comparatorのcompareメソッドのように、実装すべきメソッドが1つしか無いインタフェース（関数型インタフェース）はラムダ式で記述可能
	- 引数の丸括弧、型、中身が省略可能な場合も
	- 処理が1つならreturn, 波カッコ, セミコロンも省略可能
	- メソッド参照
		- `list.forEach(System.out::println)` は `list.forEach(s -> System.out.println(s))` と同じ
		- 引数の数と型が一致していれば、処理の内容としてメソッドそのものを代入できる
		- `{インスタンス/クラス名}::{メソッド名}`、`this::{メソッド名}`
- streamの作成
	- `list.stream()`
	- `Arrays.stream(array)`
	- Mapの場合はEntrySetを取得してから、そのSetのStreamメソッドを呼び出すことで生成
		- `map.entrySet().stream().forEach(e -> /* something for e.getKey() and e.getValue() */)`
	- 数値レンジ
		- `IntStream.range(1, 5)` 末尾含まず
		- `IntStream.rangeClosed(1, 5)` 末尾含む
			- 同様に `LongStream`, `DoubleStream` も
- 中間操作
	- 要素を置き換える `map` 系いろいろ
		- `mapToInt`, `mapToDouble`, `mapToLong` にすると、戻り値が数値ストリームになるので、その後でsumやaverageのような数値処理メソッドが使える
		- `flatMap` は、`map` だと『Xのリストのストリーム』になるものが、flattenして『Xのストリーム』になる
	- 要素を絞り込む
		- `filter`, `limit`, `distinct`
	- `sorted` comparatorを渡してソートできる
- 終端操作
	- `forEach` で各要素に対するアクション実行
	- `collect(Collectors.xxx)`, `toArray`, `reduce` で結果をコレクションや数値としてまとめて返す
	- `findFirst`, `findAny`, `min`, `max` で1要素を取り出す
		- `min`, `max` は引数にcomparatorを
	- 集計 `count`, `min`, `max`, `sum`, `average`
		- 数値ストリームに対してのみ有効
		- `min`, `max` の引数不要
- Stream APIの中でも `map`, `filter`, `collect` は特によく使う
- ラムダ式という意味では、Java8から増えたListの `removeif(v -> xxx)`, `replaceAll(v -> xxx)` や、Mapの `compute`, `computeIfPresent`, `computeIfAbsent` も覚えておくと良い
- Listの初期化にStream APIが使える
	- `IntStream.of(1, 2, 3, 4).boxed().collect(Collectors.toList())`
	- `IntStream.range(0, 10).boxed().collect(Collectors.toList())`
		- `boxed()` で int -> Integer のboxing
	- `Stream.of("AAA", "BBB", "CCC").collect(Collectors.toList())`
- 配列の初期化でも使える
	- `Integer[] array = IntStream.of(1,2,3,4).boxed().toArray(n -> new Integer[n])`

## 6. 例外を極める

- 大きく分けて3種類の例外
	- 検査例外 (Exception) `java.lang.Exception`
		- コンパイルエラーになるような、プログラム作成時に予測できる例外
		- `throws` 句をメソッドシグネチャにつけてプログラム側での補足（try-catch）を強制
		- 筆者はミッションクリティカルなエンプラシステムを扱うことがあるので、たとえコードが長大化しても賛成
	- 実行時例外 (Runtime Exception) `java.lang.RuntimeException`
		- 誰も補足しなければ、（スレッドを開始した）Java VMまで例外が伝搬されてスレッドが終了する
	- エラー (Error) `java.lang.Error`
		- システムを継続できない致命的なもの e.g., OOM
		- プログラムで補足すべきではない
- tryブロックの中の処理は最小限に
- リソースの解放漏れを防ぐ
	- Java 6 まで：try ~ catch ~ finally の finally で
	- Java 7 から：try-with-resources構文
		- `try (InputStream is = File.newInputStream(path); ...) { ~ } catch { ~ }`
		- tryの中でAutoClosableインタフェースの実装クラスを宣言すれば、終了時に勝手にcloseしてくれる
- 同様にハンドリングしたい例外はマルチキャッチする `catch (XxxException | YyyException e) { ~ }`
- なにかあったときにエラーコードをreturnしないで、きちんとJavaの例外機構を使う
	- Cのように例外機構を言語仕様として定めていない場合はいいけど、Javaはそれがあるから、失敗したらきちんと例外を発する
	- ただし、何でもかんでもthrowすればいいというわけでもない；`isXxx()`というメソッドはbooleanを戻すことが明らかなので、throwせずfalseを返せばいいかもしれない
- catchした例外をもみ消さない（catch内で何かしらの処理をする）
	- ログ出力（スタックトレースなど）
	- 処理の継続判定
		- オブジェクトが存在しないことをcatchしてログに出すだけだと、あとで再びそれを参照してNPEになるだけ
		- catchしたらデフォルト値を設定してあげるか、そこで処理を終了するか
- `throws Exception` はNG
	- すべての呼び出し元で `throws Exception` をしなければならない＆それにもかかわらず全ての具体的な例外がそれに巻き込まれる
	- どうしてもExceptionを補足しなければならないときはある
		- 依存ライブラリが `throws Exception` してる←独自の例外でラップしてしまうのも手
		- スレッドプール内のワーカースレッドなど、どんな例外があっても常に処理を継続させたい場合
- どの部分で例外を補足・処理すべきか
	1. 例外が発生する（可能性のある）箇所
		- たいていは末端の処理で、数が多く、そこで個別に例外をハンドリングするのは全体の流れを見づらくするだけ
		- なので、例外は発生させるだけに留める
	2. 処理の流れを判断する箇所
		- ここで例外を補足し、処理の終了・継続を判断する
		- 大きなシステムなら、補足する階層はできるだけ上位がいい；どこで補足するかはプログラム設計段階で認識を合わせておきたい
- 独自例外
	- 独自に、様々な例外たちを統一的に扱いたい場合につくる
	- 親のException, RuntimeExceptionには引数を取らない場合もあるが、独自例外では引数強制にして意味のある例外にすべき
	- 筆者のおすすめはメッセージの代わりにエラーIDとパラメータをとる例外
		- 実際のメッセージを『エラーIDに対応する情報』として例外定義の外に追い出せる
		- プログラマごとにエラーメッセージが違う（けどコンテキストは同じ）という状況が回避できる
		- メッセージ生成はログ出力クラスや例外ハンドラで行う
- 例外のトレンド
	1. ExceptionよりRuntimeException
		- フレームワークの独自例外はだいたいRuntimeException
		- プログラム開始部分に近い共通部分でまとめて例外処理をさせたいねらい
	2. ラムダ式の中で発生した例外の扱い
		- ラムダ式内で発生した実行時例外はラムダ式の外側に例外が伝わり、それを補足できる
		- ただし、処理する要素ひとつひとつが発した例外すべてを受け取れるわけではないので、「処理する要素次第でコケることもある」というときはラムダ式の内側で例外を補足したほうがよい
	3. Java8から導入されたOptionalクラスによる、nullチェックからの解放＆NPEの抑止
		- ただ、Optionalは`isPresent()`による値の存在確認が必須になり、nullチェックと手間が変わらない説
			- nullチェック：開発者の注意次第
			- Optional：オブジェクトを返す側で、値が存在する場合と存在しない場合、それぞれのコードを書くことを開発者に強制できる

## 7. 文字列操作を極める

- 文字列の結合：StringBuilderでappend, +, "xxx".concat("yyy")
	- ループで繰り返し結合するときは、StringBuilder.appendが圧倒的に早い
		- +やconcatはループ毎に文字列オブジェクト生成処理を繰り返している
		- `"xxx" + "yyy"` はコンパイラによって `new StringBuilder(String.valueOf("xxx").append("yyy")).toString()` に変換されるが、これをループしても毎回無駄にStringBuilderと文字列オブジェクトが生成されるのでパフォーマンス低
	- StringBuilderのスレッドセーフ版、StringBufferもある
- Java8からは `String.join()` が標準
- 分割・置換のStringクラス使用vs正規表現
	- 一度だけならStringクラスのメソッドをつかって簡潔にかけばいい
	- 大量の文字列に対して何回もやるなら、事前に正規表現オブジェクトを生成して使いまわす
- 「デプロイしたら文字化けする」問題にはまらないために、（特にサーバサイドJavaの開発では）デフォルトエンコーディングを使わないよう意識することが大切
	- 引数なしでStringコンストラクタやStringクラスの `getBytes` を使ったり、FileReader, FileWriterなどを使うとデフォルトエンコーディングになってしまう
		- 必ず引数でcharset, エンコーディングを指定する or エンコーディング指定オプションのあるメソッドで代替する
	- サロゲートペア（2文字で1文字を表現したやつ）の扱い
		- 禁止するなら `Character.isLowSurrogate(c)` や `Character.isHighSurrogate(c)` で確認してエラーを出せばいい
		- 許容するなら、文字数カウントなどで注意が必要
			- `str.length()` よりも `str.codePointCount(0, str.length())` つかったり
	- 文字列比較は equals を使わないと、同じ中身でもオブジェクトとしては別になってしまう
		- `"aaa"` と `"a" + "aa"` は文字列としては同じ、でも `==` で比較すれば false
		- `("a" + "aa").intern()` とすれば、明示的に両者を同一オブジェクトとして扱える

## 8. ファイル操作を極める

- ファイルを「簡潔なコードで」「安全に」「効率よく」扱うことが大切
- ファイルもディレクトリも `new File(path)` で読める
	- これにはファイルのメタデータ、シンボリックリンクが扱えない問題があって、ディレクトリ配下のファイルの生成・削除・更新の監視もできなかった
	- なのでJava7から登場した `Paths.get(path)`のほうがよい
- バイナリファイルはすべてメモリに読み込まず、ストリームとして少しずつ読む
	- `Files.newInputStream()`
	- Java7以降は try-with-resources でストリームを閉じる処理を省略
	- 書き込み `Files.newOutputStream()` も同様に try-with-resources 構文でかける
- テキストは文字コード指定が重要なので、 `Files.newInputStream()` ではなくて `Files.newBufferedReader()` を利用
	- Java6以前は FileInputStream -> InputStreamReader -> BufferedReader という3段階が必要だったが、これなら1回で済む
	- 書き込みは `Files.newBufferedWriter()`
- Java8ではStream APIを使ったさらに高度なファイル読み込みが可能
	- `reader.lines().map(...).forEach(...)` など
- `Files` はファイルの作成、削除、コピー、ディレクトリ作成のシンプルなインタフェースも提供
	- 一時ファイルも `Files.createTempFile()` でつくれる；一時的に必要なファイルは都度作成・削除処理を書いたり、ファイル名のコンフリクトを避けたり、といった実装が大変なので便利
- パラメータを外部定義するとき、Javaがデフォルトで読み込み機構をもっているプロパティファイルにすることが多い
	- `new Properties().load(reader).getProperty("key")`
	- ファイル `xxx_ja.properties` と `xxx_en.properties` があると、`ResourceBundle.getbundle("xxx")` でPCの言語設定に応じた方を読んでくれる；国際化対応が可能（文字コードはISO 8859-1のみで、UTF-8は無理）
- プロパティファイルが複雑になる場合はXMLにすることも
	- DOM
		- XMLファイルのInputStreamを `DocumentBuilder` でnodeにパースして読む
		- ツリー構造をすべて読み込むのでメモリに優しくはない
	- SAX (Simple API for XML)
		- 構文解析を勧めながらイベント（e.g., 開/閉タグにたどりつく）ドリブンで必要な情報を取得していく
		- `SAXParser` `SimpleHandler` を利用
		- イベント時の処理をコールバックで指定（プッシュ型イベントドリブン）
	- StAX (Streaming API for XML)
		- SAXと似ているが、readerをループで舐めていってイベントがあったら処理をする、というプル型のイベントドリブン
			- 「パース途中で処理を中止」みたいなことが可能
	- XPath (Xml Path language)
		- XMLから条件に適合した部分だけを取り出す
	- JAXB (Java Architecture for XML Binding)
		- XMLファイルとJavaオブジェクトを結びつける
		- XMLの構造に対応するクラスを作っておいて、InputStreamをそれにバインディング
- CSVはSuperCSV, JSONはJackson

## 9. 日付処理を極める

- `Data` or `Calendar` を使う場合、両者の相互変換が必要
	- `Date`: ある特定の日時を“タイムスタンプ”で表すクラス
		- 日時の画面への表示やユーザ入力の読み取り・保持が可能
	- `Calendar`: 年、月、日、時、分、秒といった単位で日時を表現できて、日時に関する計算も可能
		- 文字列との相互変換はできない
	- `DateFormat` クラスで文字列との相互変換もやりやすくできる
		- ただし、これではスレッドセーフではないので、フォーマッターを使いまわすのはNG；同一フォーマッターが同時に利用されると意図しない値が返る可能性がある
		- フォーマッターに渡す文字列を定数として保持して、都度 `DateFormat` クラスのインスタンスを生成すること
- 使い分けが面倒、しかも immutable じゃない → Java8からはどちらの長所も備えた **Data and Time API** が追加
	- クラス
		- `LocalDate` - 年、月、日
		- `LocalTime` - 時、分、秒
		- `LocalDateTime`
	- 文字列との相互変換は `DateTimeFormatter` クラスを利用
		- `DateTimeFormatter.ofPattern("yyyy-MM-dd").format(LocalDate.now())`
		- これはスレッドセーフ
- Java8 からは標準で和暦に対応したクラスも用意されている
	- `java.time.chrono.JapaneseDate`

## 10. オブジェクト指向をたしなむ

- 値渡し（プリミティブ型）と参照渡しの挙動の違いに注意
-	筆者のルール
	1. 原則として、引数オブジェクトの修正は避ける
	2. 戻り値がvoidなら、引数オブジェクトを修正してもよい
	3. 戻り値がvoid以外なら、引数オブジェクトの修正はNG
		- 引数も変更されるのが想像しにくい
- MutableなクラスとImmutableなクラスを使い分けるべし
	- 後者は意図しない書き換えを事前に防げるので「安心感」がある
	- しかしImmutableなクラスはオブジェクトが大量に生成される問題がある
	- ↓は、Stringがimmutableなので `text +=` でその都度新しいStringオブジェクトが生成されている
	```java
	String text = "";
	for (int i = 0; i < 10000; i ++) {
		text += String.valueOf(i) + ", ";
	}
	```
	- Immutable なクラスの値の変更が↑のように（擬似的に）できるが、ループ内でそれをやるとパフォーマンスに影響
- 可視性（アクセス修飾子）を適切に設定してバグを減らす
	- public > protected > package private（何も指定しない） > private
	- Good practices
		1. 原則、最も範囲が狭い可視性にする
			- クラスのフィールドは private
			- 外部からアクセスするメソッドのみ public
		2. 拡張性をあげるために protected にする
			- 筆者は将来に向けた拡張性の向上（継承クラスでのoverrideの可能性）を優先して、private よりも protected を好んで利用
		3. テスト容易性をあげるために protected にする
			- 同一パッケージ内のテストクラスで、リフレクション無しで値の上書き、テストができる
			- リフレクションは対象のフィールドを文字列で指定して操作するので、リファクタリングに弱く、できれば避けたい
- オブジェクトのライフサイクルを把握する
	1. ローカル変数
		- 処理のブロック `{ ~ }` が終了した時点で破棄される
	2. インスタンス変数（クラスのフィールド）
		- 親オブジェクト（親のインスタンス）の生成時に生成されて、親オブジェクトがガベコレされるときに一緒に破棄
	3. クラス変数（クラスのstaticフィールド）
		- Javaで最も長いライフサイクルをもつ
		- クラスロード時に生成され、クラスアンロード時に破棄される（多くはJavaのプロセス起動時＆終了時）
- ライフサイクルのgood practices
	1. ライフサイクルを短くして事故を防ぐ
		- インスタンス変数はローカル変数に置き換えられないか検討
		- 具体的には『必要な値はその都度メソッドの引数として渡す』『数が多い場合は値を保持する専用のクラスにまとめて、そのインスタンスを引数にとる』など
			- マルチスレッドの文脈では値のセット<>目的の処理の間のインターリーブが問題になるので、特に大切
	2. ライフサイクルを長くして性能をあげる
		- ライフサイクルを短くすると、GCの発生回数が増加する
		- 長くすれば、値の再利用によってGCの発生回数が抑えられる“場合がある”（逆もあり、ライフサイクルが長いとかえってGC回数が増えることも）
		- インスタンス変数、クラス変数などのフィールドを持たないクラス（＝ステートレスなクラス）は複数スレッドアクセスによる事故の心配もないので、ライフサイクルを長くしてもOK
- 全メソッドが static なユーティリティクラスを作る場合
	- 拡張性がなく、テスト時にモック化できなくて面倒なので、筆者はユーティリティメソッドは非staticでつくり、利用時にユーティリティクラスのインスタンスを明示的にstaticで生成する
- 『定数インタフェース』（定数だけを定義したインタフェースをつくって、それを利用するクラスでimplements）は避ける
	- 異なる特性をもったクラスが同一のインタフェースを実装するので、本来の利用用途から逸れる
	- 定数インタフェースが不要になった場合の変更が容易ではない
	- 利用しない定数までついてくる
	- 同じことをしたければ『定数クラス』を定義してそれを呼ぼう
- インタフェースは「定義」（何を渡せば、何が返ってくるのか）に、抽象クラスは「雛形」「共通処理」に使う
	- `interface Service`
		- I/Oを定義
	- `abstract class AbstractService implements Service`
		- 共通処理を定義
	- 拡張
		- `class Service1 extends AbstractService`
		- `class Service2 extends AbstractService`
- Java8ではインタフェースがデフォルト実装を持てるようになった
	- `interface Service { default void xxx(String... args) { ... } }`
	- 背景：Java8 から Stream API 用のメソッドを List に追加する必要が出た
	- → List, ArrayList, ...すべてを書き換える必要
	- → それは厳しいので、Java7互換を保ちつつ、8では新メソッドを使えるように、Listに `stream()` などのデフォルト実装を追加
	- 苦しまぎれの策として追加された機能なので、今後もJava7以前と同様に共通実装には抽象クラスを作る方がわかりやすい
	- 多重継承やmix-inでは使える
- さらにJava8ではインタフェースがメソッドの実装を持つことも可能 & staticメソッドの定義も可能
	- ファクトリメソッドとして便利
	- Java7までで作っていたファクトリクラスのシンプルな代替ともいえる

## 11. スレッドセーフをたしなむ

- マルチスレッドで困ること
	1. メモリ使用量増加
		- スレッド管理自体にもメモリ消費するし、100や1000のスレッドをむやみに作成すると問題になる
	2. スループット低下
		- スレッド切り替えが多発すると、そのオーバーヘッドが無視できないため
	3. 同時に作業する場合特有の問題
		- ＝競合
- スレッドセーフであるために、起こしてはいけない問題
	1. 同一データのsyncなき上書き
	2. デッドロック
	3. 競合の結果発生する予期せぬ例外
		- e.g., 実際に読みにいった領域が、直前の別スレッドのアクセスで空になっていた
	4. 無限ループの発生
		- `HashMap` はスレッドセーフじゃないので、`synchronized` で保護せずに複数スレッドからputすると無限ループが発生することも
- マルチスレッド化は、問題の再現性が低く、深い理解の求められる作業
	- 「スレッドを作らない」という選択肢もある
	- フレームワーク側でマルチスレッド化に勝手に対応してくれることもあるから
- Def: スレッドセーフとは
	- 複数スレッドから読み書きを行っても
		- データが破損しない
		- 処理エラーが発生しない
		- デッドロックが発生しない
- スレッドセーフではない処理たち
	- intのインクリメント
		- 「現在の値の読み取り」「1を加算した結果の書き戻し」の2つからなるので、この2つがatomicに実行されないと（＝複数スレッドが無秩序にこれを行う）と値が正しくならない
	- `SimpleDateFormat` の format メソッド
		- `synchronized` で保護さえていないメソッドなので、インスタンス内の各属性（時、分、秒…）が順番に操作される過程で、違う値に設定される可能性アリ
	- `HashMap` の put メソッド
		- 複数スレッドから同時にputすると無限ループになることが
		- マシンのスペックによっては発生しづらい現象
	- `ArrayList` の add/remove メソッド
		- `iterator` を使用してリストの要素を処理しているときに、他スレッドからリストの add/remove が行われると `ConcurrentModificationException` が発生
			- カーソルの位置がおかしくなり、フェイルファストによって終了する
	- `javax.xml.bind.Marshaller` の marshal メソッド
		- HotSpot系のJava VMでは同時に呼ぶとNPE
	- long（プリミティブ変数）への代入
		- 複数スレッドから同時に代入するだけで値が壊れることがある
		- 64bitであるlong型を 32bit Java VM で扱う場合、上位/下位の32bitを別々に操作するので、代入操作が重複するとダメ
			- ＝上位と下位の32ビット操作はatomicに行われない
- スレッドセーフにするポイント
	1. ステートレスにする（クラス変数、インスタンス変数を持たない）
		- 渡したい変数たちをServiceクラスなどでラップしてわざわざ保持せず、都度引数として渡すようにすることで属性をできるだけ削除
		- 処理の結果を使って何かをするとき（結果として得られるオブジェクトはimmutableに）
			- コールバック
			- Futureパターン
	2. 「メソッド単位」ではなく、必要最低限な「一連の処理」に対して `synchronized`
		- HashMapのputメソッドを呼ぶ一行だけ、とか、ConcurrentHashMapを使うだけ、とかは単一のポイントは保護できても、一連の処理がアトミックに実行されることは保証しない
			- なので、 synchronizedメソッド（`public synchronized void increment() { ... }`）のように、処理の塊を同期化
		- synchronizedメソッドが同期してくれる範囲
			1. 同一クラス内のsynchronizedメソッドは同期し合う
				- クラスが異なれば同期しない
			2. 同一ロックオブジェクトに対するsynchronizedのみが同期し合う
				- synchronizedメソッド ＝ `synchronized(this) { ... }` であり、クラス自身をロックオブジェクトとした同期
				- `this` 以外を対象にした同期 `synchronized(xxx) { ... }` とは非同期
			3. 同一クラスの同一メソッドでも、そのインスタンスが異なればロックはかからない
			4. 全く同じ処理でも、ロックオブジェクトのインスタンスが異なればロックはかからない
		- ただし、synchronizedブロックの範囲を広く取りすぎると、そこはすべてシングルスレッドで実行され、各スレッドの待ち時間も増えてスループット低下
			- 狭すぎず広すぎず、適切なロック範囲を設定すること